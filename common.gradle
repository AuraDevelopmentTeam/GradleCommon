// =================================================
//     ____                                __
//    /  _/____ ___   ____   ____   _____ / /_ _____
//    / / / __ `__ \ / __ \ / __ \ / ___// __// ___/
//  _/ / / / / / / // /_/ // /_/ // /   / /_ (__  )
// /___//_/ /_/ /_// .___/ \____//_/    \__//____/
//                /_/
//
// =================================================

import static com.xlson.groovycsv.CsvParser.parseCsv

import io.franzbecker.gradle.lombok.task.DelombokTask
import java.security.SecureRandom
import java.util.regex.*
import java.util.stream.Collectors
import org.apache.tools.ant.filters.ReplaceTokens
import proguard.gradle.ProGuardTask

// =============================================================
//     ____         ____ _         _  __   _
//    / __ \ ___   / __/(_)____   (_)/ /_ (_)____   ____   _____
//   / / / // _ \ / /_ / // __ \ / // __// // __ \ / __ \ / ___/
//  / /_/ //  __// __// // / / // // /_ / // /_/ // / / /(__  )
// /_____/ \___//_/  /_//_/ /_//_/ \__//_/ \____//_/ /_//____/
//
// =============================================================

final String NONE = "none"
final String BUNGEECORD = "bungeecord"
final String SPIGOT = "spigot"
final String SPONGE = "sponge"

ext {
    if (project.hasProperty("buildOffset")) {
        if (buildOffset instanceof String)
            buildOffset = Integer.parseInt(buildOffset)
    } else
        buildOffset = 0

    gitDescription = "git describe --dirty".execute(null, projectDir).text.trim()
}

def getBuild() {
    def commits = "git rev-list --count HEAD".execute(null, projectDir).text.trim()

    return (project.buildOffset + commits.toInteger()).toString()
}
def getBuildType() {
    if (project.gitDescription.endsWith("dirty"))
        return "SNAPSHOT"
    else if(project.gitDescription.contains("-"))
        return "DEV"
    else
        return "RELEASE"
}
def getVersion() {
    def baseVersion = gitDescription.replaceAll("^v|-.*", "") + ".${project.buildNum}"
    def branch = project.hasProperty("branchName")? branchName : ("git describe --all".execute().text.trim().replaceFirst(".*/", ""))

    if ((branch != "master") && !branch.matches("^v\\d+\\.\\d+.\\d+\$"))
        baseVersion += "-${branch}"

    if (buildType != "RELEASE")
        baseVersion += "-${buildType}"

    return baseVersion
}
def getChangelog() {
    try {
        Pattern pattern = Pattern.compile("^Version .*?(?= {0,2}\\n{0,3}Version)", Pattern.DOTALL);
        Matcher match = pattern.matcher(file("CHANGELOG.md").text.replaceAll("\r", ""));

        if (match.find())
            return match.group();
    } catch(IOException e) {
        println e
    }

    return "Empty";
}
def printCoverageText(projectName, coverageInstructions, coverageBranches, coverageLines, coverageComplexity, coverageMethods) {
    println String.format("Covered %.2f%% of instructions for ${projectName}.", ((double)coverageInstructions[1] / (double)coverageInstructions[0]) * 100.0)
    println String.format("Covered %.2f%% of branches for ${projectName}.", ((double)coverageBranches[1] / (double)coverageBranches[0]) * 100.0)
    println String.format("Covered %.2f%% of lines for ${projectName}.", ((double)coverageLines[1] / (double)coverageLines[0]) * 100.0)
    println String.format("Covered %.2f%% of complexity for ${projectName}.", ((double)coverageComplexity[1] / (double)coverageComplexity[0]) * 100.0)
    println String.format("Covered %.2f%% of methods for ${projectName}.", ((double)coverageMethods[1] / (double)coverageMethods[0]) * 100.0)
}

// ===============================================
//
//    _____        __   __   _
//   / ___/ ___   / /_ / /_ (_)____   ____ _ _____
//   \__ \ / _ \ / __// __// // __ \ / __ `// ___/
//  ___/ //  __// /_ / /_ / // / / // /_/ /(__  )
// /____/ \___/ \__/ \__//_//_/ /_/ \__, //____/
//                                 /____/
//
// ===============================================

if (!project.hasProperty("type")) {
    throw new NoSuchElementException("No type is specified!")
} else if ((type != NONE) && (type != BUNGEECORD) && (type != SPIGOT) && (type != SPONGE)) {
    throw new IllegalArgumentException("The type \"${type}\" is unknown.\nUse either \"${NONE}\", \"${BUNGEECORD}\", \"${SPIGOT}\" or \"${SPONGE}\"")
} else if (!project.hasProperty("pluginId")) {
    throw new NoSuchElementException("No pluginId is specified!")
}

ext {
    if (!project.hasProperty("pluginName")) pluginName = name
    if (!project.hasProperty("baseGroup")) baseGroup = "dev.aura"

    buildNum = getBuild()
    buildType = getBuildType()

    if (project.hasProperty("openSource")) {
        if (openSource instanceof String)
            openSource = Boolean.parseBoolean(openSource)
    } else
        openSource = true
    if (!project.hasProperty("secretSalt")) secretSalt = "CHANGEME"
    if (project.hasProperty("useStats")) {
        if (useStats instanceof String)
            useStats = Boolean.parseBoolean(useStats)
    } else
        useStats = (type != NONE)
    if (project.hasProperty("customCharts")) {
        if (customCharts instanceof String)
            customCharts = Boolean.parseBoolean(customCharts)
    } else
        customCharts = false

    shouldSign = project.hasProperty("signing.keyId") && project.hasProperty("signing.password") && project.hasProperty("signing.secretKeyRingFile")
    mainDirResources = fileTree(dir: file(projectDir), includes: ["CHANGELOG", "CHANGELOG.md", "CHANGELOG.txt", "LICENSE", "LICENSE.md", "LICENSE.txt", "README", "README.md", "README.txt"])

    // default versions

    if (!project.hasProperty("lombokVersion")) lombokVersion = "1.16.18"
    if (!project.hasProperty("lombokHash")) lombokHash = "9d957f572386b9e257093a45b148f9b411cff80d9efd55eaf6fca27002d2e4d9"

    if (!project.hasProperty("bungeecoord_version")) bungeecoord_version = "1.12-SNAPSHOT"
    if (!project.hasProperty("spigot_version")) spigot_version = "1.12-R0.1-SNAPSHOT"
    if (!project.hasProperty("sponge_version")) sponge_version = "7.0.0-SNAPSHOT"

    if (!project.hasProperty("bStats_version")) bStats_version = "1.2"
}

version = getVersion()
if (description == null) description = "Empty description"
if (project != rootProject) ext.baseGroup = project.parent.group
group = "${baseGroup}.${pluginId}"

ext {
    if (useStats) bStatsName = "bstats-" + ((type == SPIGOT)? "bukkit" : type) + (customCharts? "" : "-lite")
    commonManifest = {
        attributes(
            "Specification-Title": pluginName,
            "Specification-Version": version,
            "Specification-Vendor": "Aura Development Team",
            "Implementation-Title": pluginName,
            "Implementation-Version": version,
            "Implementation-Vendor": "Aura Development Team"
        )
    }
}

// ==========================================
//
//     ____   __               _
//    / __ \ / /__  __ ____ _ (_)____   _____
//   / /_/ // // / / // __ `// // __ \ / ___/
//  / ____// // /_/ // /_/ // // / / /(__  )
// /_/    /_/ \__,_/ \__, //_//_/ /_//____/
//                  /____/
//
// ==========================================

buildscript {
    repositories {
        jcenter()
        mavenCentral()
        maven {
            name "Gradle-Plugins"
            url "https://plugins.gradle.org/m2/"
        }
    }

    dependencies {
        classpath "net.sf.proguard:proguard-gradle:5.3.3"
        classpath "io.franzbecker:gradle-lombok:1.8"
        classpath "com.github.jengelman.gradle.plugins:shadow:2.0.0"
        classpath "gradle.plugin.org.spongepowered:spongegradle:0.8.1"
        classpath "com.xlson.groovycsv:groovycsv:1.2"
    }
}

apply plugin: "java"
apply plugin: "jacoco"
apply plugin: "maven"
apply plugin: "maven-publish"
apply plugin: "signing"
apply plugin: "eclipse"
apply plugin: "idea"
apply plugin: io.franzbecker.gradle.lombok.LombokPlugin
apply plugin: com.github.jengelman.gradle.plugins.shadow.ShadowPlugin

if (type == SPONGE)
    apply plugin: org.spongepowered.gradle.plugin.SpongePluginPlugin

// ==============================================================================
//
//    ______               ____ _                             __   _
//   / ____/____   ____   / __/(_)____ _ __  __ _____ ____ _ / /_ (_)____   ____
//  / /    / __ \ / __ \ / /_ / // __ `// / / // ___// __ `// __// // __ \ / __ \
// / /___ / /_/ // / / // __// // /_/ // /_/ // /   / /_/ // /_ / // /_/ // / / /
// \____/ \____//_/ /_//_/  /_/ \__, / \__,_//_/    \__,_/ \__//_/ \____//_/ /_/
//                             /____/
//
// ==============================================================================

eclipse {
    classpath {
        downloadJavadoc = true
        downloadSources = true
    }
}

idea {
    module {
        downloadJavadoc = true
        downloadSources = true
    }
}

configurations {
    reTrace
    shadowRelocate
    shadow.extendsFrom shadowRelocate
    compile.extendsFrom shadow
}

repositories {
    jcenter()
    mavenCentral()

    maven {
        name "bungeecord-repo"
        url "https://oss.sonatype.org/content/repositories/snapshots"
    }
    maven {
        name "spigot-repo"
        url "https://hub.spigotmc.org/nexus/content/repositories/snapshots"
    }
    maven {
        name = "sponge"
        url = "https://repo.spongepowered.org/maven"
    }
    maven {
        name "bstats-repo"
        url "http://repo.bstats.org/content/repositories/releases"
    }
}

dependencies {
    if (type == BUNGEECORD) {
        compile "net.md-5:bungeecord-api:${bungeecoord_version}"
    } else if (type == SPIGOT) {
        compile "org.spigotmc:spigot-api:${spigot_version}"
    } else if (type == SPONGE) {
        compile "org.spongepowered:spongeapi:${sponge_version}"
    }

    if (useStats) {
        shadowRelocate "org.bstats:${bStatsName}:${bStats_version}"
    }

    testCompile "junit:junit:4.12"

    if (!openSource)
        reTrace "net.sf.proguard:proguard-retrace:5.3.3"
}

if (type == SPONGE) {
    sponge {
        plugin {
            meta {
                id = pluginId
                name = pluginName
                version = version
                description = description
            }
        }
    }

    compileJava {
        outputs.upToDateWhen { false }
        doFirst { println() }
    }
}

lombok {
    version = lombokVersion
    sha256 = lombokHash
}

processResources {
    // this will ensure that this task is redone when the versions change.
    inputs.property "pluginId", project.pluginId
    inputs.property "pluginName", project.pluginName
    inputs.property "description", project.description
    inputs.property "version", project.version
    inputs.property "buildNum", project.buildNum
    inputs.property "buildType", project.buildType

    from(sourceSets.main.resources.srcDirs) {
        exclude "lang"
        exclude "*.conf"

        expand \
            "id": project.pluginId,
            "name": project.pluginName,
            "description": project.description,
            "version": project.version,
            "build": project.buildNum,
            "buildType": project.buildType
    }
}

task processSources (type: Sync) {
    inputs.property "pluginId", project.pluginId
    inputs.property "pluginName", project.pluginName
    inputs.property "description", project.description
    inputs.property "version", project.version
    inputs.property "buildNum", project.buildNum
    inputs.property "buildType", project.buildType
    ext.outputDir = file("$buildDir/generated-src")

    from sourceSets.main.allSource
    into outputDir
    filter (ReplaceTokens, tokens: [
        "id": project.pluginId,
        "name": project.pluginName,
        "description": project.description,
        "version": project.version,
        "build": project.buildNum,
        "buildType": project.buildType
    ])
}

task delombok(type: DelombokTask, dependsOn: compileJava) {
    group "build"
    description "Generates Lombok free Java code from code with Lombok"

  	ext.outputDir = file("$buildDir/delombok")

  	outputs.dir(outputDir)
		inputs.dir(processSources.outputDir)
		args(processSources.outputDir, "-d", outputDir)

    doLast {
        fileTree(dir: outputDir, exclude: "**/*.java").forEach{file -> file.delete()}
    }
}

compileJava {
    source = processSources.outputs
    dependsOn processSources
}

tasks.withType(JavaCompile) {
    options.encoding = "UTF-8"
    options.incremental = true
    options.deprecation = true
}

tasks.withType(Jar) {
    manifest commonManifest
}

jar {
    from sourceSets.main.output
    from mainDirResources
}

task sourceJar (type: Jar, dependsOn: processSources) {
    group "build"

    from sourceSets.main.allSource
    from mainDirResources

    classifier = "sources"
    version = jar.version
}

javadoc {
    dependsOn delombok

    source = delombok.outputDir
    classpath = sourceSets.main.compileClasspath
}

task javadocJar(type: Jar, dependsOn: javadoc) {
    group "build"

    from javadoc.destinationDir

    classifier = "javadoc"
    version = jar.version
}

shadowJar {
    from sourceSets.main.output
    from mainDirResources

    classifier = openSource? null : "deobf"
    version = jar.version
    configurations = [project.configurations.shadow]

    doFirst {
        project.configurations.shadowRelocate.dependencies.each {
            relocate(it.group, "${project.group}.shadow.${it.group}")
        }
    }
}

if (!openSource) {
    task proguard(type: ProGuardTask, dependsOn: shadowJar) {
        group "build"

        def dictonary = file("dictionary.txt")

        // Inputs and outputs
        injars shadowJar.archivePath
        outjars jar.archivePath
        printmapping "${jar.archivePath}.map"

        // Libraries
        libraryjars "${System.getProperty('java.home')}/lib/rt.jar"               // Most platforms
        libraryjars "${System.getProperty('java.home')}/../Classes/classes.jar"   // MacOS X
        libraryjars configurations.compile

        // General settings
        renamesourcefileattribute pluginName
        keepattributes "Exceptions,InnerClasses,Signature,Deprecated,SourceFile,LineNumberTable,*Annotation*,EnclosingMethod"
        dontshrink
        dontoptimize
        adaptresourcefilecontents "**.yml"
        adaptresourcefilecontents "**.info"

        // Stuff that depends on the group name
        keep "class ${rootProject.baseGroup}.**.api.** { *; }"
        keep "class ${rootProject.baseGroup}.**.shadow.** { *; }"
        repackageclasses project.group

        // No notes or warnings from classes that aren't ours!
        dontwarn "!class ${rootProject.baseGroup}.**|class ${rootProject.baseGroup}.**.shadow.**"
        dontnote "!class ${rootProject.baseGroup}.**|class ${rootProject.baseGroup}.**.shadow.**"

        // Obfuscation names. They'll be different for each version
        classobfuscationdictionary dictonary
        obfuscationdictionary dictonary

        jar.finalizedBy proguard

        doFirst {
            def firstChars = ('A'..'Z') + ('a'..'z')
            def allChars = firstChars + ('0'..'9')
            def rand = SecureRandom.getInstance("SHA1PRNG")
            rand.setSeed("${version}${secretSalt}".getBytes("UTF-8"))
            def str
            def out = ""

            (1..10000).each {
                str = firstChars[rand.nextInt(firstChars.size())]

                (2..3).each {
                    str += allChars[rand.nextInt(allChars.size())]
                }

                out += "${str}\n"
            }

            dictonary.text = out;
        }

        doLast {
           dictonary.delete()
        }
    }
}

test {
    beforeTest { descriptor ->
        logger.lifecycle("Running test: " + descriptor)
    }

    onOutput { descriptor, event ->
       logger.lifecycle("Test: " + descriptor + " produced standard out/err: " + event.message )
    }
}

task generateTestReport(type: Zip, dependsOn: test) {
    from file("${buildDir}/reports/tests/test")
    archiveName "${project.name}-TestReport.zip"
    destinationDir rootProject.projectDir

    test.finalizedBy generateTestReport
}

clean.dependsOn cleanGenerateTestReport

artifacts {
    if (openSource) {
        archives shadowJar
        archives sourceJar
        archives javadocJar
    } else {
        archives jar
    }
}

signing {
    required { project.hasProperty("signing.keyId") && project.hasProperty("signing.password") && project.hasProperty("signing.secretKeyRingFile") }

    sign configurations.archives
}

uploadArchives {
    repositories {
        mavenDeployer {
            if (shouldSign) {
                beforeDeployment { MavenDeployment deployment -> signing.signPom(deployment) }
            }

            if (project.hasProperty("local_maven")) {
                repository(url: "file://${local_maven}")
            } else {
                repository(url: "file://${rootProject.projectDir}/maven")
            }

            pom {
                groupId = rootProject.group
                version = project.version
                artifactId = project.archivesBaseName
                project {
                    name project.archivesBaseName
                    packaging "jar"
                    description project.description
                    url "https://gitlab.brainstonemod.com/AuraDev/${project.archivesBaseName}"
                    scm {
                        url "https://gitlab.brainstonemod.com/AuraDev/${project.archivesBaseName}"
                        connection "scm:git:git@gitlab.brainstonemod.com:AuraDev/${project.archivesBaseName}.git"
                        developerConnection "scm:git:gitlab.brainstonemod.com:AuraDev/${project.archivesBaseName}.git"
                    }
                    issueManagement {
                        system "github"
                        url "https://github.com/AuraDevelopmentTeam/${project.archivesBaseName}/issues"
                    }
                    licenses {
                        license {
                            name "License"
                            url "https://github.com/AuraDevelopmentTeam/${project.archivesBaseName}/blob/master/LICENSE.md"
                            distribution "repo"
                        }
                    }
                    developers {
                        developer {
                            id "shawn_ian"
                            name "shawn_ian"
                            roles {
                                role "developer"
                                role "team leader"
                            }
                            id "brainstone"
                            name "The_BrainStone"
                            roles {
                                role "developer"
                                role "development leader"
                            }
                            id "ryada"
                            name "Ryada"
                            roles {
                                role "helper developer"
                            }
                        }
                    }
                }
            }
        }
    }
}

// =====================================================
//
//     ______
//    / ____/____  _   __ ___   _____ ____ _ ____ _ ___
//   / /    / __ \| | / // _ \ / ___// __ `// __ `// _ \
//  / /___ / /_/ /| |/ //  __// /   / /_/ // /_/ //  __/
//  \____/ \____/ |___/ \___//_/    \__,_/ \__, / \___/
//                                        /____/
//
// =====================================================

jacocoTestReport {
    reports {
        csv.enabled true
    }
}

if (project == rootProject) {
    ext {
        coverageInstructions = [0, 0]
        coverageBranches = [0, 0]
        coverageLines = [0, 0]
        coverageComplexity = [0, 0]
        coverageMethods = [0, 0]
    }

    task printFinalCoverage {
        doLast {
            printCoverageText("all projects", coverageInstructions, coverageBranches, coverageLines, coverageComplexity, coverageMethods)
        }
    }
}

task generateCoverageReport(type: Zip, dependsOn: jacocoTestCoverageVerification) {
    from file("${buildDir}/reports/jacoco/test/html")
    archiveName "${project.name}-CoverageReport.zip"
    destinationDir rootProject.projectDir

    jacocoTestReport.finalizedBy generateCoverageReport
}

task printCoverage(dependsOn: generateCoverageReport) {
    doLast {
        def instructions = [0, 0]
        def branches = [0, 0]
        def lines = [0, 0]
        def complexity = [0, 0]
        def methods = [0, 0]

        for(line in parseCsv(new FileReader(file("${buildDir}/reports/jacoco/test/jacocoTestReport.csv")))) {
            instructions[0] += Integer.parseInt(line.INSTRUCTION_MISSED) + Integer.parseInt(line.INSTRUCTION_COVERED)
            instructions[1] += Integer.parseInt(line.INSTRUCTION_COVERED)
            branches[0] += Integer.parseInt(line.BRANCH_MISSED) + Integer.parseInt(line.BRANCH_COVERED)
            branches[1] += Integer.parseInt(line.BRANCH_COVERED)
            lines[0] += Integer.parseInt(line.LINE_MISSED) + Integer.parseInt(line.LINE_COVERED)
            lines[1] += Integer.parseInt(line.LINE_COVERED)
            complexity[0] += Integer.parseInt(line.COMPLEXITY_MISSED) + Integer.parseInt(line.COMPLEXITY_COVERED)
            complexity[1] += Integer.parseInt(line.COMPLEXITY_COVERED)
            methods[0] += Integer.parseInt(line.METHOD_MISSED) + Integer.parseInt(line.METHOD_COVERED)
            methods[1] += Integer.parseInt(line.METHOD_COVERED)
        }

        printCoverageText(project.name, instructions, branches, lines, complexity, methods)

        rootProject.coverageInstructions[0] += instructions[0]
        rootProject.coverageInstructions[1] += instructions[1]
        rootProject.coverageBranches[0] += branches[0]
        rootProject.coverageBranches[1] += branches[1]
        rootProject.coverageLines[0] += lines[0]
        rootProject.coverageLines[1] += lines[1]
        rootProject.coverageComplexity[0] += complexity[0]
        rootProject.coverageComplexity[1] += complexity[1]
        rootProject.coverageMethods[0] += methods[0]
        rootProject.coverageMethods[1] += methods[1]
    }

    generateCoverageReport.finalizedBy printCoverage
    finalizedBy rootProject.printFinalCoverage
    rootProject.printFinalCoverage.dependsOn printCoverage
}

task coverage(dependsOn: [test, jacocoTestReport, generateCoverageReport, printCoverage, rootProject.printFinalCoverage, jacocoTestCoverageVerification]) {}

check.dependsOn coverage
jacocoTestReport.dependsOn test
rootProject.printFinalCoverage.finalizedBy jacocoTestCoverageVerification

clean.dependsOn cleanGenerateTestReport

// ==========================================================================
//
//    _____                     _         __   ______              __
//   / ___/ ____   ___   _____ (_)____ _ / /  /_  __/____ _ _____ / /__ _____
//   \__ \ / __ \ / _ \ / ___// // __ `// /    / /  / __ `// ___// //_// ___/
//  ___/ // /_/ //  __// /__ / // /_/ // /    / /  / /_/ /(__  )/ ,<  (__  )
// /____// .___/ \___/ \___//_/ \__,_//_/    /_/   \__,_//____//_/|_|/____/
//      /_/
// ==========================================================================

if (!openSource) {
    task reTrace(type: JavaExec) {
        group "help"
        description """Deobfuscates an obfuscated stacktrace
Specify "-Pmapping_file=<file>" (with quotes) to use a given mapping file. If not provided use (and generate if necessary) the mapping file of the current code.
Specify "-Pstacktrace_file=<file>" (with quotes) to specify the stacktrace file. If not provided "stacktrace.txt" (in the project root) is used."""

        classpath configurations.reTrace
        main = "proguard.retrace.ReTrace"

        def mapping_file
        def stacktrace_file

        if (project.hasProperty("mapping_file")) {
            mapping_file = project.mapping_file
        } else {
            dependsOn proguard

            mapping_file = "${jar.archivePath}.map"
        }

        if (project.hasProperty("stacktrace_file")) {
            stacktrace_file = project.stacktrace_file
        } else {
            stacktrace_file = "stacktrace.txt"
        }

        args mapping_file
        args stacktrace_file
    }
}

if (project == rootProject) {
    task gitTag {
        group "help"
        description """Tags the current version in git.
Specify "-Pminor" to update the minor version.
Specify "-Pmajor" to update the major version."""

        doLast {
            def newVersion = Arrays.stream(project.version.split("\\."), 0, 3).map{num -> Integer.parseInt(num)}.toArray()

            if (project.hasProperty("major")) {
                newVersion[0]++;
                newVersion[1] = 0;
                newVersion[2] = 0;
            } else if (project.hasProperty("minor")) {
                newVersion[1]++;
                newVersion[2] = 0;
            } else {
                newVersion[2]++;
            }

            newVersion = Arrays.stream(newVersion).map{num -> Integer.toString(num)}.collect(Collectors.joining("."))

            exec {
                executable "git"
                args "tag", "-a", "v${newVersion}", "-m", getChangelog().replace("\"", "\\\"")
            }
        }
    }

    task updateGradleCommon(dependsOn: ":GradleCommon:updateGradleCommon") {}

    task addGitHooks(type: Copy) {
        from "GradleCommon/hooks"
        into ".git/hooks"
    }
}

println """Project Info:
=============

Plugin ID:\t${pluginId}
Plugin Name:\t${pluginName}
Description:\t${description}
Version:\t${version}
Build:\t\t${buildNum}
Build Type:\t${buildType}
Group:\t\t${group}

Settings:
---------

Type:\t\t${type}
Open Source:\t${openSource}
Use Stats:\t${useStats}
Custom Charts:\t${customCharts}
"""
